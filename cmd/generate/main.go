package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"text/template"

	"github.com/isaacphi/mcp-language-server/cmd/generate/methods"
)

// Template functions
var templateFuncs = template.FuncMap{
	"sub": func(a, b int) int {
		return a - b
	},
}

func main() {
	// Create output directory
	outDir := "internal/lsp/methods"
	if err := os.MkdirAll(outDir, 0755); err != nil {
		log.Fatalf("Failed to create output directory: %v", err)
	}

	// Collect all method definitions
	methodDefs := []methods.MethodDef{}

	// Add methods from each category
	methodDefs = append(methodDefs, methods.GeneralMethods()...)
	methodDefs = append(methodDefs, methods.TextDocumentMethods()...)

	// Generate files
	if err := generateMethodsFile(outDir, methodDefs); err != nil {
		log.Fatalf("Failed to generate methods file: %v", err)
	}

	if err := generateRegistryFile(outDir, methodDefs); err != nil {
		log.Fatalf("Failed to generate registry file: %v", err)
	}

	if err := generateConvertersFile(outDir, methodDefs); err != nil {
		log.Fatalf("Failed to generate converters file: %v", err)
	}
}

func generateMethodsFile(outDir string, methods []methods.MethodDef) error {
	var buf bytes.Buffer

	// Write package header with imports and wrapper type
	buf.WriteString(`// Code generated by "generate"; DO NOT EDIT.
package methods

import (
	"fmt"
	"github.com/kralicky/tools-lite/gopls/pkg/protocol"
	"github.com/isaacphi/mcp-language-server/internal/lsp"
)

// Wrapper provides type-safe methods for LSP operations
type Wrapper struct {
	client *lsp.Client
}

// NewWrapper creates a new LSP method wrapper
func NewWrapper(client *lsp.Client) *Wrapper {
	return &Wrapper{client: client}
}
`)

	// Write method declarations
	for _, method := range methods {
		tmpl := requestTemplate
		if method.IsNotification {
			tmpl = notificationTemplate
		}

		t := template.Must(template.New("method").Funcs(templateFuncs).Parse(tmpl))
		if err := t.Execute(&buf, method); err != nil {
			return fmt.Errorf("failed to execute template: %v", err)
		}
		buf.WriteString("\n")
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format source: %v", err)
	}

	// Write to file
	filename := filepath.Join(outDir, "generated.go")
	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write file: %v", err)
	}

	return nil
}

func generateRegistryFile(outDir string, methods []methods.MethodDef) error {
	var buf bytes.Buffer

	// Write package header
	buf.WriteString(`// Code generated by "generate"; DO NOT EDIT.
package methods

// Registry maintains the mapping of LSP method names to their handlers
type Registry struct {
	methods map[string]bool
}

// NewRegistry creates a new method registry
func NewRegistry() *Registry {
	return &Registry{
		methods: make(map[string]bool),
	}
}

// RegisterMethod marks a method as available
func (r *Registry) RegisterMethod(name string) {
	r.methods[name] = true
}

// HasMethod checks if a method is available
func (r *Registry) HasMethod(name string) bool {
	return r.methods[name]
}

// Known LSP methods
const (
`)

	// Write method constants
	for _, method := range methods {
		constName := method.GoName() + "Method"
		buf.WriteString(fmt.Sprintf("\t%s = %q\n", constName, method.Name))
	}

	buf.WriteString(")\n")

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format source: %v", err)
	}

	// Write to file
	filename := filepath.Join(outDir, "registry.go")
	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write file: %v", err)
	}

	return nil
}

func generateConvertersFile(outDir string, methods []methods.MethodDef) error {
	var buf bytes.Buffer

	// Write package header
	buf.WriteString(`// Code generated by "generate"; DO NOT EDIT.
package methods

import (
	"github.com/kralicky/tools-lite/gopls/pkg/protocol"
)
`)

	// Find all methods that need converters
	for _, method := range methods {
		if len(method.ResponseTypes) > 1 {
			primary := method.ResponseTypes[0]
			for _, rt := range method.ResponseTypes[1:] {
				if rt.NeedsConvert {
					// Generate converter function
					fmt.Fprintf(&buf, `
// convert%sTo%s converts from %s to %s
func convert%sTo%s(from protocol.%s) protocol.%s {
    return protocol.%s{
        Name:           from.Name,
        Kind:           from.Kind,
        Range:          from.Location.Range,
        SelectionRange: from.Location.Range,
        Detail:         from.ContainerName,
    }
}
`, rt.Type, primary.Type, rt.Type, primary.Type, rt.Type, primary.Type, rt.Type, primary.Type, primary.Type)

					if rt.IsSlice {
						fmt.Fprintf(&buf, `
// convert%sSliceTo%sSlice converts a slice of %s to a slice of %s
func convert%sSliceTo%sSlice(from []protocol.%s) []protocol.%s {
    result := make([]protocol.%s, len(from))
    for i, item := range from {
        result[i] = convert%sTo%s(item)
    }
    return result
}
`, rt.Type, primary.Type, rt.Type, primary.Type, rt.Type, primary.Type, rt.Type, primary.Type, primary.Type, rt.Type, primary.Type)
					}
				}
			}
		}
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format source: %v", err)
	}

	// Write to file
	filename := filepath.Join(outDir, "converters.go")
	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write file: %v", err)
	}

	return nil
}
